<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>3D Model Repairing -- Widen the Thin Wall | Enjoy Short Life</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Widen the thin wallThe workflow consists of two parts. Considering the efficiency of algorithm, rasterization is firstly execuated for later detection. And then">
<meta property="og:type" content="article">
<meta property="og:title" content="3D Model Repairing -- Widen the Thin Wall">
<meta property="og:url" content="https://sunyasheng.github.io/2017/12/06/3-Dimensional-Reconstruction-from-2-Dimensional-Slicing/index.html">
<meta property="og:site_name" content="Enjoy Short Life">
<meta property="og:description" content="Widen the thin wallThe workflow consists of two parts. Considering the efficiency of algorithm, rasterization is firstly execuated for later detection. And then by enumerating all the grids offset is">
<meta property="og:image" content="https://sunyasheng.github.io/2017/12/06/3-Dimensional-Reconstruction-from-2-Dimensional-Slicing/content/images/2017/12/offset_result.png">
<meta property="og:updated_time" content="2018-01-20T11:06:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="3D Model Repairing -- Widen the Thin Wall">
<meta name="twitter:description" content="Widen the thin wallThe workflow consists of two parts. Considering the efficiency of algorithm, rasterization is firstly execuated for later detection. And then by enumerating all the grids offset is">
<meta name="twitter:image" content="https://sunyasheng.github.io/2017/12/06/3-Dimensional-Reconstruction-from-2-Dimensional-Slicing/content/images/2017/12/offset_result.png">
  
    <link rel="alternate" href="/atom.xml" title="Enjoy Short Life" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Enjoy Short Life</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sunyasheng.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-3-Dimensional-Reconstruction-from-2-Dimensional-Slicing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/06/3-Dimensional-Reconstruction-from-2-Dimensional-Slicing/" class="article-date">
  <time datetime="2017-12-06T05:54:48.000Z" itemprop="datePublished">2017-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      3D Model Repairing -- Widen the Thin Wall
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Widen-the-thin-wall"><a href="#Widen-the-thin-wall" class="headerlink" title="Widen the thin wall"></a>Widen the thin wall</h2><p>The workflow consists of two parts. Considering the efficiency of algorithm, rasterization is firstly execuated for later detection. And then by enumerating all the grids offset is applied to contours one by one.</p>
<h3 id="Code-for-Rasterization"><a href="#Code-for-Rasterization" class="headerlink" title="Code for Rasterization"></a>Code for Rasterization</h3><p>In this part, all the contours are simply cut by grids.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ptr_slice_-&gt;GetNumPieces(); i++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; &gt; contours; contours.clear();</span><br><span class="line">		New2Origin layerlinenew2origin;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pieces_[i].size(); j++) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; contour; contour.clear();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pieces_[i][j].size(); k++) &#123;</span><br><span class="line">				<span class="keyword">double</span> x1 = pieces_[i][j][k].first[<span class="number">0</span>]; <span class="keyword">double</span> y1 = pieces_[i][j][k].first[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">double</span> x2 = pieces_[i][j][k].second[<span class="number">0</span>]; <span class="keyword">double</span> y2 = pieces_[i][j][k].second[<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; godis; godis.clear();</span><br><span class="line">				godis.insert(<span class="number">0</span>); godis.insert(<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="keyword">int</span>( min(x1, x2)/MIN_DIS); ii &lt; <span class="keyword">int</span>(max(x1, x2) / MIN_DIS); ii++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!(x1 &lt; ii*MIN_DIS&amp;&amp;ii*MIN_DIS&lt;x2))<span class="keyword">continue</span>;</span><br><span class="line">					godis.insert((ii*MIN_DIS - x1) / (x2 - x1));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="keyword">int</span>( min(y1, y2)/MIN_DIS); jj &lt; <span class="keyword">int</span>(max(y1, y2) / MIN_DIS); jj++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!(y1&lt;jj*MIN_DIS&amp;&amp;jj*MIN_DIS&lt;y2))<span class="keyword">continue</span>;</span><br><span class="line">					godis.insert((jj*MIN_DIS - y1) / (y2 - y1));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt;::iterator it;</span><br><span class="line">				<span class="keyword">double</span> last_it;</span><br><span class="line">				<span class="keyword">for</span> (it = godis.begin(); it != godis.end(); ++it) &#123;</span><br><span class="line">					<span class="keyword">if</span> (it != godis.begin() &amp;&amp; <span class="built_in">abs</span>(*it - last_it)&lt;eps)<span class="keyword">continue</span>;</span><br><span class="line">					last_it = *it;</span><br><span class="line">					layerlinenew2origin.layermap[j][contour.size()] = k;</span><br><span class="line">					contour.push_back(<span class="built_in">std</span>::make_pair(x1 + *it*(x2 - x1), y1 + *it*(y2 - y1)));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			contours.push_back(contour);</span><br><span class="line">		&#125;</span><br><span class="line">		lines_new2origin.push_back(layerlinenew2origin);</span><br><span class="line">		layers.push_back(contours);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>After cutting, new generated contours are stored in its corresponding grids.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; layers[i].size(); j++) &#123;</span><br><span class="line">	IsInner.push_back(!JudgeLoopDir(layers[i][j]));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; layers[i][j].size(); k++) &#123;</span><br><span class="line">		layer_offdis.dis[j].push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">double</span> x1 = layers[i][j][k].first, x2 = layers[i][j][(k + <span class="number">1</span>) % layers[i][j].size()].first;</span><br><span class="line">		<span class="keyword">double</span> y1 = layers[i][j][k].second, y2 = layers[i][j][(k + <span class="number">1</span>) % layers[i][j].size()].second;</span><br><span class="line">		<span class="keyword">double</span> x = <span class="number">0.5</span>*(x1 + x2), y = <span class="number">0.5</span>*(y1 + y2);</span><br><span class="line">		<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; g = point2grid(<span class="built_in">std</span>::make_pair(x, y));</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; a.push_back(g.first); a.push_back(g.second); a.push_back(j); a.push_back(layer_grids[g].grids[j].size());</span><br><span class="line">		lineincontour[a] = k;</span><br><span class="line">		layer_grids[g].grids[j].push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(x1, y1), <span class="built_in">std</span>::make_pair(x2, y2)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Offset-in-each-grids"><a href="#Offset-in-each-grids" class="headerlink" title="Offset in each grids"></a>Offset in each grids</h3><p>Code for calculating offseting distance required for each line in a contour.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (it1 = layer_grids.begin(); it1 != layer_grids.end(); it1++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = it1-&gt;first.first, y = it1-&gt;first.second;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">				<span class="keyword">int</span> next_x = x + dir[k][<span class="number">0</span>], next_y = y + dir[k][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (vis.find(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(x, y), <span class="built_in">std</span>::make_pair(next_x, next_y))) != vis.end())<span class="keyword">continue</span>;</span><br><span class="line">				vis.insert(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(next_x, next_y), <span class="built_in">std</span>::make_pair(x, y))); vis.insert(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(next_x, next_y), <span class="built_in">std</span>::make_pair(x, y)));</span><br><span class="line">				it2 = layer_grids.find(<span class="built_in">std</span>::make_pair(next_x, next_y));</span><br><span class="line">				<span class="keyword">if</span> (it2 == layer_grids.end())<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt; layers[i].size(); j1++) <span class="keyword">if</span> (it1-&gt;second.grids[j1].size()) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; layers[i].size(); j2++)<span class="keyword">if</span> (it2-&gt;second.grids[j2].size()) &#123;</span><br><span class="line">						<span class="keyword">if</span> (IsInner[j1] &amp;&amp; IsInner[j2] &amp;&amp; j1 != j2) &#123;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; it1-&gt;second.grids[j1].size(); k1++) &#123;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; it2-&gt;second.grids[j2].size(); k2++) &#123;</span><br><span class="line">									pa p[<span class="number">3</span>][<span class="number">3</span>], optimal_dir, offdir[<span class="number">3</span>];</span><br><span class="line">									p[<span class="number">1</span>][<span class="number">1</span>] = it1-&gt;second.grids[j1][k1].first, p[<span class="number">1</span>][<span class="number">2</span>] = it1-&gt;second.grids[j1][k1].second;</span><br><span class="line">									p[<span class="number">2</span>][<span class="number">1</span>] = it2-&gt;second.grids[j2][k2].first, p[<span class="number">2</span>][<span class="number">2</span>] = it2-&gt;second.grids[j2][k2].second;</span><br><span class="line">									optimal_dir = furthestdir(p);</span><br><span class="line">									<span class="keyword">double</span> line_dis = <span class="built_in">sqrt</span>(dot(optimal_dir, optimal_dir));</span><br><span class="line">									<span class="comment">//line_dis = sqrt((p[1][1].first + p[1][2].first - p[2][1].first - p[2][2].first) * (p[1][1].first + p[1][2].first - p[2][1].first - p[2][2].first)* 0.25 + (p[1][1].second + p[1][2].second - p[2][1].second - p[2][2].second) *(p[1][1].second + p[1][2].second - p[2][1].second - p[2][2].second)*0.25);</span></span><br><span class="line">									<span class="keyword">double</span> move = (MIN_DIS - line_dis);</span><br><span class="line">									<span class="keyword">if</span> (move &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; a.push_back(x); a.push_back(y); a.push_back(j1); a.push_back(k1);</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b; b.push_back(next_x); b.push_back(next_y); b.push_back(j2); b.push_back(k2);</span><br><span class="line">									layer_offdis.dis[j1][lineincontour[a]] = max(move*<span class="number">0.5</span>, layer_offdis.dis[j1][lineincontour[a]]);</span><br><span class="line">									layer_offdis.dis[j2][lineincontour[b]] = max(move*<span class="number">0.5</span>, layer_offdis.dis[j2][lineincontour[b]]);</span><br><span class="line">									<span class="comment">//if (dot(p1, optimal_dir) &gt; 0 &amp;&amp; dot(p1, optimal_dir) &lt; 0)</span></span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (IsInner[j1] &amp;&amp; !IsInner[j2] &amp;&amp; j1 != j2) &#123;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; it1-&gt;second.grids[j1].size(); k1++) &#123;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; it2-&gt;second.grids[j2].size(); k2++) &#123;</span><br><span class="line">									pa p[<span class="number">3</span>][<span class="number">3</span>], optimal_dir, offdir[<span class="number">3</span>];</span><br><span class="line">									p[<span class="number">1</span>][<span class="number">1</span>] = it1-&gt;second.grids[j1][k1].first, p[<span class="number">1</span>][<span class="number">2</span>] = it1-&gt;second.grids[j1][k1].second;</span><br><span class="line">									p[<span class="number">2</span>][<span class="number">1</span>] = it2-&gt;second.grids[j2][k2].first, p[<span class="number">2</span>][<span class="number">2</span>] = it2-&gt;second.grids[j2][k2].second;</span><br><span class="line">									optimal_dir = furthestdir(p);</span><br><span class="line">									<span class="keyword">double</span> line_dis = <span class="built_in">sqrt</span>(dot(optimal_dir, optimal_dir));</span><br><span class="line">									<span class="keyword">double</span> move = (MIN_DIS - line_dis);</span><br><span class="line">									<span class="keyword">if</span> (move &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; a.push_back(x); a.push_back(y); a.push_back(j1); a.push_back(k1);</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b; b.push_back(next_x); b.push_back(next_y); b.push_back(j2); b.push_back(k2);</span><br><span class="line">									layer_offdis.dis[j1][lineincontour[a]] = max(move, layer_offdis.dis[j1][lineincontour[a]]);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (!IsInner[j1] &amp;&amp; IsInner[j2] &amp;&amp; j1 != j2) &#123;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; it1-&gt;second.grids[j1].size(); k1++) &#123;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; it2-&gt;second.grids[j2].size(); k2++) &#123;</span><br><span class="line">									pa p[<span class="number">3</span>][<span class="number">3</span>], optimal_dir, offdir[<span class="number">3</span>];</span><br><span class="line">									p[<span class="number">1</span>][<span class="number">1</span>] = it1-&gt;second.grids[j1][k1].first, p[<span class="number">1</span>][<span class="number">2</span>] = it1-&gt;second.grids[j1][k1].second;</span><br><span class="line">									p[<span class="number">2</span>][<span class="number">1</span>] = it2-&gt;second.grids[j2][k2].first, p[<span class="number">2</span>][<span class="number">2</span>] = it2-&gt;second.grids[j2][k2].second;</span><br><span class="line">									optimal_dir = furthestdir(p);</span><br><span class="line">									<span class="keyword">double</span> line_dis = <span class="built_in">sqrt</span>(dot(optimal_dir, optimal_dir));</span><br><span class="line">									<span class="keyword">double</span> move = (MIN_DIS - line_dis);</span><br><span class="line">									<span class="keyword">if</span> (move &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; a.push_back(x); a.push_back(y); a.push_back(j1); a.push_back(k1);</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b; b.push_back(next_x); b.push_back(next_y); b.push_back(j2); b.push_back(k2);</span><br><span class="line">									layer_offdis.dis[j2][lineincontour[b]] = max(move, layer_offdis.dis[j2][lineincontour[b]]);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (!IsInner[j1] &amp;&amp; !IsInner[j2] &amp;&amp; j1 == j2) &#123;</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt; it1-&gt;second.grids[j1].size(); k1++) &#123;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; it2-&gt;second.grids[j2].size(); k2++) <span class="keyword">if</span> (k1 != k2) &#123;</span><br><span class="line">									pa p[<span class="number">3</span>][<span class="number">3</span>], optimal_dir, offdir[<span class="number">3</span>];</span><br><span class="line">									p[<span class="number">1</span>][<span class="number">1</span>] = it1-&gt;second.grids[j1][k1].first, p[<span class="number">1</span>][<span class="number">2</span>] = it1-&gt;second.grids[j1][k1].second;</span><br><span class="line">									p[<span class="number">2</span>][<span class="number">1</span>] = it2-&gt;second.grids[j2][k2].first, p[<span class="number">2</span>][<span class="number">2</span>] = it2-&gt;second.grids[j2][k2].second;</span><br><span class="line">									optimal_dir = furthestdir(p);</span><br><span class="line">									<span class="keyword">double</span> line_dis = <span class="built_in">sqrt</span>(dot(optimal_dir, optimal_dir));</span><br><span class="line">									<span class="keyword">double</span> move = (MIN_DIS - line_dis);</span><br><span class="line">									<span class="keyword">if</span> (move &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">									pa p1, p2; p1.first = p[<span class="number">1</span>][<span class="number">1</span>].first - p[<span class="number">1</span>][<span class="number">2</span>].first; p1.second = p[<span class="number">1</span>][<span class="number">1</span>].second - p[<span class="number">1</span>][<span class="number">2</span>].second;</span><br><span class="line">									p2.first = p[<span class="number">2</span>][<span class="number">1</span>].first - p[<span class="number">2</span>][<span class="number">2</span>].first; p2.second = p[<span class="number">2</span>][<span class="number">1</span>].second - p[<span class="number">2</span>][<span class="number">2</span>].second;</span><br><span class="line">									<span class="keyword">if</span> (dot(p1, p2) &gt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; a.push_back(x); a.push_back(y); a.push_back(j1); a.push_back(k1);</span><br><span class="line">									<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b; b.push_back(next_x); b.push_back(next_y); b.push_back(j2); b.push_back(k2);</span><br><span class="line">									layer_offdis.dis[j2][lineincontour[b]] = max(move, layer_offdis.dis[j2][lineincontour[b]]);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		offdis.push_back(layer_offdis);</span><br></pre></td></tr></table></figure></p>
<p>Below is the code to offset each contour.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderingWidget::LayerOffset(LayerOffDis layer_offdis, <span class="keyword">int</span> layernum) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; IsInner;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; layers[layernum].size(); j++) &#123;</span><br><span class="line">		IsInner.push_back(!JudgeLoopDir(layers[layernum][j]));</span><br><span class="line">	&#125;</span><br><span class="line">	Paths final_clippers, subs, tmp_res, tmp_res1, res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layers[layernum].size(); i++) <span class="keyword">if</span> (IsInner[i]) &#123;</span><br><span class="line">		Path sub, clipper; ClipperOffset offset; Clipper difference; Paths clippers;</span><br><span class="line">		<span class="keyword">double</span> max_d = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; layers[layernum][i].size(); j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> d = layer_offdis.dis[i][j];</span><br><span class="line">			ClipperLib::cInt x = ScaleNumber*layers[layernum][i][j].first;</span><br><span class="line">			ClipperLib::cInt y = ScaleNumber*layers[layernum][i][j].second;</span><br><span class="line">			max_d = max(max_d, d);</span><br><span class="line">			sub &lt;&lt; IntPoint(x, y);</span><br><span class="line">			<span class="keyword">if</span> (max_d&gt;eps)clipper &lt;&lt; IntPoint(x, y);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(d) &lt; eps&amp;&amp;max_d&gt;eps) &#123;</span><br><span class="line">				offset.AddPath(clipper, jtMiter, etOpenButt);</span><br><span class="line">				offset.Execute(clippers, max_d*ScaleNumber); ClipperLib::CleanPolygons(clippers);</span><br><span class="line">				difference.AddPaths(clippers, ptClip, TRUE);</span><br><span class="line">				max_d = <span class="number">0</span>;</span><br><span class="line">				clipper.clear();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (clipper.size()) &#123;</span><br><span class="line">			offset.AddPath(clipper, jtMiter, etOpenButt);</span><br><span class="line">			offset.Execute(clippers, max_d*ScaleNumber); ClipperLib::CleanPolygons(clippers);</span><br><span class="line">			difference.AddPaths(clippers, ptClip, TRUE);</span><br><span class="line">			clipper.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sub.size())subs.push_back(sub);<span class="comment">/* DrawPaths(subs, layernum);*/</span></span><br><span class="line">		difference.AddPath(sub, ptSubject, TRUE);</span><br><span class="line">		difference.Execute(ctDifference, tmp_res, pftNonZero, pftNonZero);  ClipperLib::CleanPolygons(tmp_res);</span><br><span class="line">		tmp_res1.clear(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp_res.size(); j++)<span class="keyword">if</span> (<span class="built_in">fabs</span>(Area(tmp_res[j]))*<span class="number">1.0</span> / ScaleNumber / ScaleNumber &gt;= MIN_DIS*MIN_DIS*<span class="number">0.2</span>)tmp_res1.push_back(tmp_res[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp_res1.size(); j++)<span class="keyword">if</span> (tmp_res1[j].size())res.push_back(tmp_res1[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layers[layernum].size(); i++) <span class="keyword">if</span> (!IsInner[i]) &#123;</span><br><span class="line">		Path sub, clipper; ClipperOffset offset; Clipper difference; Paths clippers;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; layers[layernum][i].size(); j++) &#123;</span><br><span class="line">			ClipperLib::cInt x = ScaleNumber*layers[layernum][i][j].first;</span><br><span class="line">			ClipperLib::cInt y = ScaleNumber*layers[layernum][i][j].second;</span><br><span class="line">			sub &lt;&lt; IntPoint(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		res.push_back(sub);</span><br><span class="line">	&#125;</span><br><span class="line">	res_path.push_back(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="content/images/2017/12/offset_result.png" alt="Fig.1. Offset Result" style="width: 400px;"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunyasheng.github.io/2017/12/06/3-Dimensional-Reconstruction-from-2-Dimensional-Slicing/" data-id="cjhzod66z0000wos6y7px9lvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/08/An-Elegant-Way-to-Cover-Line-Segments-with-Grids/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          An Elegant Way to Cover Line Segments with Grids
        
      </div>
    </a>
  
  
    <a href="/2017/12/05/Particle-Swarm-Optimization/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Particle Swarm Optimization</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/21/Byesian-Summary/">Summary of Byesian Theory</a>
          </li>
        
          <li>
            <a href="/2018/03/18/Torch-Tutorial/">Torch_Tutorial</a>
          </li>
        
          <li>
            <a href="/2018/03/04/GAN-Workflow/">GAN Workflow</a>
          </li>
        
          <li>
            <a href="/2018/02/04/Introduction-of-Pascal-VOC-Dataset/">Introduction of Pascal VOC Dataset</a>
          </li>
        
          <li>
            <a href="/2018/02/04/Frequently-Used-Script/">Frequently Used Script</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  
	<!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Yasheng Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>